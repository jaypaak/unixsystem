<html>

<head>
  <meta charset="UTF-8">
  <title>Bash Shell</title>
</head>

<body>
  <h1>Chapter 05: Bash Shell</h1>
  <h3>Author: 19100586 unix101</h3>

  <ul>
    <p>Types of Shells</p>
    <li>
      Prompt: %
      <ul>
        <li>csh</li>
      </ul>
    </li>
    <li>
      Prompt: $
      <ul>
        <li>sh</li>
        <li>bash</li>
        <li>ksh</li>
      </ul>
    </li>
  </ul>

  <p><strong>**</strong>Login Shell: A shell automatically created when the user logs in.<br>
    Sub Shell: A shell run manually after login (can be a different type of shell).</p>

  <h4>Special Characters in Shell</h4>
  <ul>
    <p>*: Represents any string</p>
    <li>$ ls *: Shows all files in the current directory, including files in subdirectories.</li>
    <li>cp * /tmp: Copies all files in the current directory to /tmp (ignores subdirectories).</li>
    <li>ls h*: Shows all files in the current directory that start with "h".</li>
    <li>rm *.cpp: Deletes all files with the .cpp extension.</li>
    <li>cp h*d: Copies all files starting with "h" and ending with "d".</li>
  </ul>

  <ul>
    <p>?, []: Used to represent a single character</p>
    <li>ls hello?: Lists files like hello1, hello2, etc., but not just "hello".</li>
    <li>rm hello[123]: Deletes hello1, hello2, and hello3.</li>
    <li>cp hello[1-3].c /tmp: Copies hello1.c, hello2.c, and hello3.c to /tmp.</li>
    <li>ls [A-Za-z]*[0-9]: Lists files starting with a letter and ending with a number.</li>
  </ul>

  <ul>
    <p>Directory Navigation</p>
    <li>~: User's home directory → cp *.c ~/clang, cd ~</li>
    <li>-: Previous directory → cd -, cd prev* -</li>
  </ul>

  <ul>
    <p>Quotation Marks</p>
    <li>"" (Double quotes): Treats all special characters as normal text except $, \, `, and ".</li>
    <li>'' (Single quotes): Treats all characters as literal text.</li>
    <li>`` (Backticks): Used to replace with the result of a command.</li>
  </ul>

  <h4>Standard Input/Output in Shell</h4>
  <p>
    Shell standard input is 0, output is 1, and error is 2. By default, both outputs go to the monitor.<br>
    Redirection methods:
  </p>
  <ul>
    <li>command (1)> or >> out.txt: Saves standard output to out.txt (> overwrites, >> appends).</li>
    <li>command 2> or >> error.txt: Saves standard error to error.txt.</li>
    <li>command > out.txt 2>&1 or command 2>out.txt >&1: Saves both output and error to out.txt.</li>
  </ul>

  <h4>When Commands Do Not Execute</h4>
  <p>
    If a command doesn't work, it might be because the shell doesn’t recognize it.<br>
    The main reason is usually a limited default PATH.<br>
    Using <code>set</code>, you might see something like: PATH=single_path:<br>
    The colon (:) means if it can’t find the command on the left path, it checks the right path.<br>
    You can use shell variables and environment variables:<br>
    Define a variable: <code>VAR=value</code><br>
    Use <code>set</code> to check the assignment, <code>echo $VAR</code> to print it.<br>
    But this doesn't apply in sub-shells. Use <code>env</code> to verify it’s not global.<br>
    To make it global: use <code>export VAR</code> or <code>export VAR=value</code> at the time of declaration.
  </p>
</body>

</html>
